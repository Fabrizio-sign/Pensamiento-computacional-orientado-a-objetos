INICIAR programa
CREAR lista_de_recetas vacía

REPETIR
    MOSTRAR menú:
        1. Agregar receta
        2. Mostrar todas las recetas
        3. Buscar receta por ingrediente
        4. Eliminar receta
        5. Salir

    LEER opcion

    SI opcion == 1 ENTONCES
        CREAR nueva_receta
        PEDIR nombre
        PEDIR tiempo_de_preparacion
        PEDIR dificultad
        PEDIR tipo_platillo

        CREAR lista_ingredientes vacía
        MIENTRAS usuario no escriba "fin"
            PEDIR ingrediente
            AGREGAR ingrediente a lista_ingredientes
        FIN MIENTRAS

        ASIGNAR lista_ingredientes a nueva_receta
        AGREGAR nueva_receta a lista_de_recetas

    SI opcion == 2 ENTONCES
        MOSTRAR cada receta con sus ingredientes

    SI opcion == 3 ENTONCES
        PEDIR ingrediente_buscado
        BUSCAR en lista_de_recetas aquellas que contengan ingrediente_buscado
        MOSTRAR coincidencias

    SI opcion == 4 ENTONCES
        PEDIR nombre_receta
        BUSCAR receta y ELIMINAR de lista_de_recetas

HASTA que opcion == 5

FINALIZAR programa


#include <iostream>
#include <string>
#include <vector>
using namespace std;

// ========== COMPOSICIÓN: Ingrediente ==========
class Ingrediente {
private:
    string nombre;
    float cantidad;
    string unidad;
public:
    Ingrediente(string n = "", float c = 0, string u = "") 
        : nombre(n), cantidad(c), unidad(u) {}
    
    string getNombre() const { return nombre; }
    float getCantidad() const { return cantidad; }
    
    void mostrar() const {
        cout << "  - " << cantidad << " " << unidad << " de " << nombre << endl;
    }
};

// ========== HERENCIA: Jerarquía de Recetas ==========
class Receta {
protected:
    string nombre;
    int tiempo;
    string dificultad;
    vector<Ingrediente*> ingredientes;  // COMPOSICIÓN
public:
    Receta(string n = "", int t = 0, string d = "") 
        : nombre(n), tiempo(t), dificultad(d) {}
    
    virtual ~Receta() {
        for (auto ing : ingredientes) delete ing;
    }
    
    void agregarIngrediente(Ingrediente* ing) {
        ingredientes.push_back(ing);
    }
    
    bool tieneIngrediente(string buscado) const {
        for (auto ing : ingredientes)
            if (ing->getNombre() == buscado) return true;
        return false;
    }
    
    virtual string getTipo() const = 0;  // Clase abstracta
    
    void mostrar() const {
        cout << "\n" << nombre << " [" << getTipo() << "]" << endl;
        cout << "Tiempo: " << tiempo << "min, Dificultad: " << dificultad << endl;
        cout << "Ingredientes:" << endl;
        for (auto ing : ingredientes) ing->mostrar();
    }
};

class RecetaCocina : public Receta {
private:
    int temperatura;
public:
    RecetaCocina(string n, int t, string d, int temp) 
        : Receta(n, t, d), temperatura(temp) {}
    
    string getTipo() const override { return "Cocina"; }
    
    void mostrar() const {
        Receta::mostrar();
        cout << "Temperatura: " << temperatura << "°C" << endl;
    }
};

class RecetaHorneado : public Receta {
private:
    int tiempoHorno;
public:
    RecetaHorneado(string n, int t, string d, int th) 
        : Receta(n, t, d), tiempoHorno(th) {}
    
    string getTipo() const override { return "Horneado"; }
    
    void mostrar() const {
        Receta::mostrar();
        cout << "Horneado: " << tiempoHorno << "min" << endl;
    }
};

// ========== COMPOSICIÓN: Recetario ==========
class Recetario {
private:
    string nombre;
    vector<Receta*> recetas;  // COMPOSICIÓN
public:
    Recetario(string n) : nombre(n) {}
    
    ~Recetario() {
        for (auto r : recetas) delete r;
    }
    
    void agregarReceta(Receta* r) {
        recetas.push_back(r);
    }
    
    void mostrar() const {
        cout << "\n=== " << nombre << " ===" << endl;
        for (auto r : recetas) r->mostrar();
    }
    
    vector<Receta*> buscarPorIngrediente(string ing) const {
        vector<Receta*> resultado;
        for (auto r : recetas)
            if (r->tieneIngrediente(ing)) resultado.push_back(r);
        return resultado;
    }
    
    int getCantidad() const { return recetas.size(); }
    string getNombre() const { return nombre; }
};

// ========== AGREGACIÓN: Chef ==========
class Chef {
private:
    string nombre;
    vector<Recetario*> recetarios;  // AGREGACIÓN (no es dueño)
public:
    Chef(string n) : nombre(n) {}
    
    void trabajarCon(Recetario* r) {
        recetarios.push_back(r);
        cout << "Chef " << nombre << " ahora trabaja con: " << r->getNombre() << endl;
    }
    
    Receta* crearReceta(string tipo) {
        cout << "\nChef " << nombre << " crea una receta de tipo: " << tipo << endl;
        if (tipo == "horneado") return new RecetaHorneado("Especial del Chef", 60, "Media", 40);
        else return new RecetaCocina("Especial del Chef", 45, "Media", 180);
    }
    
    void mostrarTrabajo() const {
        cout << "\nChef " << nombre << " trabaja con " 
             << recetarios.size() << " recetarios:" << endl;
        for (auto r : recetarios)
            cout << "  - " << r->getNombre() << " (" << r->getCantidad() << " recetas)" << endl;
    }
};

// ========== PROGRAMA PRINCIPAL ==========
int main() {
    cout << "=== SISTEMA DE RECETAS C++ ===\n";
    
    // 1. DEMOSTRACIÓN DE COMPOSICIÓN
    cout << "\n1. CREANDO RECETARIO (Composición)..." << endl;
    Recetario* familiar = new Recetario("Recetario Familiar");
    
    // Crear recetas con herencia
    Receta* lasagna = new RecetaHorneado("Lasagna", 90, "Media", 45);
    lasagna->agregarIngrediente(new Ingrediente("Pasta", 250, "g"));
    lasagna->agregarIngrediente(new Ingrediente("Carne", 500, "g"));
    lasagna->agregarIngrediente(new Ingrediente("Queso", 200, "g"));
    
    Receta* sopa = new RecetaCocina("Sopa de Tomate", 40, "Fácil", 100);
    sopa->agregarIngrediente(new Ingrediente("Tomates", 6, "unid"));
    sopa->agregarIngrediente(new Ingrediente("Cebolla", 1, "unid"));
    
    // Agregar al recetario (composición)
    familiar->agregarReceta(lasagna);
    familiar->agregarReceta(sopa);
    
    // Mostrar recetario
    familiar->mostrar();
    
    // 2. DEMOSTRACIÓN DE AGREGACIÓN
    cout << "\n2. AGREGACIÓN: Chef trabaja con recetarios..." << endl;
    Chef* chef = new Chef("Marco");
    chef->trabajarCon(familiar);  // Chef usa el recetario, pero no es dueño
    
    // Chef crea una receta especial
    Receta* especial = chef->crearReceta("horneado");
    especial->agregarIngrediente(new Ingrediente("Ingrediente Secreto", 100, "g"));
    familiar->agregarReceta(especial);
    
    chef->mostrarTrabajo();
    
    // 3. DEMOSTRACIÓN DE HERENCIA Y POLIMORFISMO
    cout << "\n3. HERENCIA: Buscando por ingrediente..." << endl;
    auto recetasConQueso = familiar->buscarPorIngrediente("Queso");
    cout << "Recetas con queso: " << recetasConQueso.size() << endl;
    
    // 4. MOSTRAR TODAS LAS RECETAS (polimorfismo)
    cout << "\n4. LISTA COMPLETA DE RECETAS:" << endl;
    familiar->mostrar();
    
    // 5. LIMPIEZA
    cout << "\n5. LIMPIANDO MEMORIA..." << endl;
    
    // NOTA: No eliminamos 'especial' porque ahora es parte del recetario
    // El recetario lo eliminará en su destructor
    
    delete chef;      // Chef se elimina, pero los recetarios siguen
    delete familiar;  // Recetario elimina todas sus recetas (composición)
    
    cout << "\n=== FIN DEL PROGRAMA ===" << endl;
    
    return 0;
}
